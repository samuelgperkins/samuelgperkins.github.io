{"version":3,"sources":["MagicCard.js","CardDatabase.js","CardPool.js","App.js","serviceWorker.js","index.js"],"names":["MagicCard","props","name","set","date","image","url","this","href","src","alt","height","Component","database","require","dbLegendary","getCardInfo","index","rawCard","cards","length","console","log","getCardInfoLegendary","getRandomCards","count","seed","year","rng","seedrandom","max","maxDate","Date","cardsToSubtract","cardCount","maxLegendary","cardCountLegendary","Array","fill","undefined","forEach","_","self","key","cardInfo","magicCardFromIndex","Math","floor","magicCardFromIndexLegendary","CardPool","user_bday","size","parseInt","map","card","App","state","generateCardPool","bind","bday","document","getElementById","value","inputSize","inputYear","setState","style","color","htmlFor","type","id","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.33490c4c.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { getCardInfo ,getCardInfoLegendary } from './CardDatabase';\r\n\r\n/* a simple component containing the card info and a URL for searching it up */\r\nexport class MagicCard extends Component {\r\n    constructor (props) {\r\n        super(props);\r\n\r\n        this.name = props.name;\r\n        this.set = props.set;\r\n        this.date = props.date;\r\n        this.image = props.image;\r\n        this.url = `https://scryfall.com/search?q=${this.name} s:${this.set}`;\r\n    }\r\n\r\n    render () {\r\n        return (\r\n        <div>\r\n            {this.name} | {this.set} - (<a href={this.url}>link</a>) <br />\r\n            <img src={this.image} alt={this.name} height=\"200\" />\r\n        </div>\r\n        );\r\n    }\r\n}\r\n\r\nMagicCard.propTypes = {\r\n    name: PropTypes.string.isRequired,\r\n    set: PropTypes.string.isRequired,\r\n    date: PropTypes.string.isRequired,\r\n    image: PropTypes.string.isRequired,\r\n}\r\n\r\n/* return a new MagicCard component given an index in our database */\r\nexport function magicCardFromIndex (index, key = 0) {\r\n    let cardInfo = getCardInfo(index);\r\n\r\n    if (cardInfo === null) {\r\n        return null;\r\n    }\r\n\r\n    return <MagicCard\r\n        name={cardInfo.name}\r\n        set={cardInfo.set}\r\n        date={cardInfo.date}\r\n        image={cardInfo.image}\r\n        key={key}\r\n    />;\r\n}\r\n\r\nexport function magicCardFromIndexLegendary (index, key = 0) {\r\n    let cardInfo = getCardInfoLegendary(index);\r\n\r\n    if (cardInfo === null) {\r\n        return null;\r\n    }\r\n\r\n    return <MagicCard\r\n        name={cardInfo.name}\r\n        set={cardInfo.set}\r\n        date={cardInfo.date}\r\n        image={cardInfo.image}\r\n        key={key}\r\n    />;\r\n}\r\n","import { magicCardFromIndex, magicCardFromIndexLegendary } from './MagicCard';\r\nconst database = require('./birthday_sorted.json');\r\nconst dbLegendary = require('./birthday-legendary_sorted.json');\r\n\r\n//2020-07-11: The Epoch Year will be the starting year to generate db/lists from. \r\n// so if someone was born in 1985, their pools from 1985-EPOCH_YEAR will all be generated from available cards\r\n// at the time of the epoch. So eventually, Setting epoch to 2020, but might test with 2010 or something to ensure correct\r\n// functionality\r\nconst EPOCH_YEAR = 2020;\r\n\r\n/* get an object with the card name, set, date, and image URL */\r\nexport function getCardInfo(index) {\r\n    let rawCard;\r\n    let cardName;\r\n    let cardSet;\r\n    let cardDate;\r\n    let cardURL;\r\n\r\n    if (index > database.cards.length) {\r\n        console.log(`Invalid card index ${index}...`);\r\n        return null;\r\n    }\r\n\r\n    rawCard = database.cards[index];\r\n    cardName = rawCard[0];\r\n    cardSet = rawCard[1];\r\n    cardDate = rawCard[2];\r\n    cardURL = rawCard[3];\r\n\r\n    return { name: cardName, set: cardSet, date: cardDate, image: cardURL };\r\n}\r\n\r\nexport function getCardInfoLegendary(index) {\r\n    let rawCard;\r\n    let cardName;\r\n    let cardSet;\r\n    let cardDate;\r\n    let cardURL;\r\n\r\n    if (index > dbLegendary.cards.length) {\r\n        console.log(`Invalid card index ${index}...`);\r\n        return null;\r\n    }\r\n\r\n    rawCard = dbLegendary.cards[index];\r\n    cardName = rawCard[0];\r\n    cardSet = rawCard[1];\r\n    cardDate = rawCard[2];\r\n    cardURL = rawCard[3];\r\n\r\n    return { name: cardName, set: cardSet, date: cardDate, image: cardURL };\r\n}\r\n\r\nexport function getRandomCards(count, seed, year) {\r\n    let seedrandom = require('seedrandom');\r\n    let rng = seedrandom(seed);\r\n    let max = cardCount(year);\r\n    let maxLegendary = cardCountLegendary(year);\r\n\r\n    let cards = new Array(count).fill(undefined);\r\n    cards.forEach((_, index, self) => {\r\n        // rng() does not affect global Math.Random() rng\r\n        // observation: rng seems to result in mannny of the same cards. Could be a nonexistant pattern *shrug*\r\n        self[index] = magicCardFromIndex(Math.floor(rng() * max), index);\r\n    });\r\n    cards[count - 1] = magicCardFromIndexLegendary(Math.floor(rng() * maxLegendary), count - 1);\r\n\r\n    return cards;\r\n}\r\n\r\nexport function cardCount(year) {\r\n    if (year > EPOCH_YEAR) {\r\n        // do something\r\n        // Sam Note: So i kinda just put the code handle dates entered below\r\n        // might actually support people putting in dates earlier than 2020, but not 1993,\r\n        // as to allow old school magic, etc. If entered below 1993 it would instead \r\n        // default to some other date, etc\r\n    }\r\n    let releaseDate;\r\n    let maxDate = new Date(year);\r\n    let cardsToSubtract = database.cards.length -1;\r\n    while(cardsToSubtract > 0){\r\n        releaseDate = new Date(database.cards[cardsToSubtract][2]);\r\n        if(releaseDate > maxDate)\r\n            cardsToSubtract--;\r\n        else\r\n            break;\r\n    }\r\n\r\n    return cardsToSubtract + 1;\r\n}\r\n\r\nexport function cardCountLegendary(year) {\r\n    if (year > EPOCH_YEAR) {\r\n        // do something\r\n        // Sam Note: So i kinda just put the code handle dates entered below\r\n        // might actually support people putting in dates earlier than 2020, but not 1993,\r\n        // as to allow old school magic, etc. If entered below 1993 it would instead \r\n        // default to some other date, etc\r\n    }\r\n    let releaseDate;\r\n    let maxDate = new Date(year);\r\n    let cardsToSubtract = dbLegendary.cards.length -1;\r\n    while(cardsToSubtract > 0){\r\n        releaseDate = new Date(dbLegendary.cards[cardsToSubtract][2]);\r\n        if(releaseDate > maxDate)\r\n            cardsToSubtract--;\r\n        else\r\n            break;\r\n    }\r\n\r\n    return cardsToSubtract + 1;\r\n}\r\n","import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { getRandomCards } from './CardDatabase';\r\n\r\nconst CARD_POOL_DEAFULT_SIZE = 45;\r\n\r\nexport class CardPool extends Component {\r\n    constructor (props) {\r\n        super(props);\r\n\r\n        this.user_bday = props.user_bday;\r\n\r\n        if (props.year === undefined) {\r\n            //this.year = new Date().getFullYear();\r\n            this.year = '2020-07-23'\r\n            //toying with a solution that can take full dates. Grandfathering in\r\n            //today's date. Will likely become a const that takes over EPOCH_YEAR\r\n        } else {\r\n            this.year = props.year;\r\n        }\r\n\r\n        if (props.size === undefined || parseInt(props.size) <= 0 || props.size == '') {\r\n            this.size = CARD_POOL_DEAFULT_SIZE;\r\n        } else {\r\n            this.size = props.size;\r\n        }\r\n\r\n        //just make it a damn int here lol\r\n        this.size = parseInt(this.size);\r\n\r\n        this.cards = getRandomCards(this.size, this.user_bday, this.year);\r\n    }\r\n\r\n    render () {\r\n        return (\r\n        <div>\r\n            <p>{this.year} pool for {this.user_bday}</p>\r\n\r\n            <ol>\r\n            {\r\n                this.cards.map((card) => {\r\n                    return <li key={card.key}>{card}</li>\r\n                })\r\n            }\r\n            </ol>\r\n        </div>\r\n        );\r\n    }\r\n}\r\n\r\nCardPool.propTypes = {\r\n    user_bday: PropTypes.string.isRequired,\r\n    year: PropTypes.string,\r\n    size: PropTypes.number,\r\n}\r\n","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport { CardPool } from './CardPool';\r\n\r\nclass App extends Component {\r\n    constructor (props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            seed: null\r\n        };\r\n\r\n        this.generateCardPool = this.generateCardPool.bind(this);\r\n    }\r\n\r\n    generateCardPool () {\r\n        let bday = document.getElementById('bday_field').value;\r\n        let inputSize = document.getElementById('size_field').value;\r\n        let inputYear = document.getElementById('year_field').value;\r\n        console.log(`New card pool for ${bday}`);\r\n        this.setState({\r\n            seed: bday,\r\n            size: inputSize,\r\n            year: inputYear\r\n        });\r\n    }\r\n\r\n    render () {\r\n        return (\r\n        <div style = {{color: \"black\"}}>\r\n            <h1>KEY MTG</h1>\r\n            <label htmlFor=\"bday_field\">Key String: </label>\r\n            <input type=\"text\" id=\"bday_field\" />\r\n            <br></br>\r\n            <i>Enter a string to generate a unique pool of cards. Suggestions: An ID#, a birthdate, a KeyForge Archon, a charity donation receipt #</i>\r\n            <br></br> \r\n            <label htmlFor=\"size_field\">Pool Size: </label>\r\n            <input type=\"text\" id=\"size_field\" />\r\n            <br></br>\r\n            <i>Defaults to 45 cards. Suggestion: try building a deck from combining multiple pools</i>\r\n            <br></br>\r\n            <label htmlFor=\"year_field\">Release Date: </label>\r\n            <input type=\"text\" id=\"year_field\" />\r\n            <br></br>\r\n            <i>yyy/mm/dd  Currently defaults and supports up to 2020/07/23</i>\r\n            <br></br>\r\n            <button onClick={this.generateCardPool} type=\"submit\">\r\n                Generate\r\n            </button>\r\n            <br></br>\r\n            <i>Currently need to refresh between Generates. Work in progress</i>\r\n            {this.state.seed === null ?\r\n                <div></div> :\r\n                <CardPool user_bday={this.state.seed} size={this.state.size} year={this.state.year} />\r\n            }\r\n        </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}